README

-------FILE CONTENTS----------------------------------------------------------------------------------------------------

addressCalculationSorting.py:
    - Counting sort
    - Bucket sort
    - Radix sort

comparisonBasedSorting.py:
    - Merge sort
    - Lower bound optimal comparison
    - Binary heaps / heap sort

deterministic_selection.py:
    - Deterministic Selection Algorithm

dijkstrasAlgorithm.py:
    - Dijkstra's Shortest Path Algorithm
    - Adjusted code from Divyanshu Mehta (Geeksforgeeks)

divideAndConquer.py:
    - Integer multiplication

greedyAlgorithms.py:
    - Fractional knapsack
    - Huffman coding
    - Merge comparisons

knapsack0-1.py:
    - 0/1 Knapsack Problem

kruskals_algorithm.py:
    - Kruskal's Algorithm
    - Adjusted code from Neelam Yadav (GeeksforGeeks)

optimal_binary_tree.py:
    - Optimal Binary Tree

optimal_matrix_chain.py:
    - Optimal matrix chain multiplication

optimalWeightedInterval.py:
    - Optimal weighted interval scheduling code from lecture (2D array)

prim_jarnik_algorithm.py:
    - Prim Jarnik Algorithm
    - Adjusted code from Divyanshu Mehta (Geeksforgeeks)

quickSelect.py:
    - Quick Select Algorithm

topologicalSort.py:
    - Topological sort for graphs

truck_loading.py:
    - Truck loading problem / subset sum



-------TEST TOPICS------------------------------------------------------------------------------------------------------

TEST 1 (Lectures 1-8):
- Asymptotic notation (Big O,Theta, Omega, little o)
- Mathematical background:
    - Sums and summations
    - Logarithms and Exponents
    - Floors and Ceilings
    - Factorials and combinations
    - Harmonic numbers
    - Proofs / Proof by induction
    - Basic Probability
- Binary trees
- Sequential Search
- Binary search: Correctness, analysis, proof of optimality using decision trees
- Sorting, basic terminology (permutations, inversions)
- The following comparison-based sorting algorithms:
    - Insertion sort
    - Selection sort
    - Quicksort, including worst-case and average-case analysis
    - Merge sort, including its use for counting inversions
- Priority Queues and Heaps
    - Priority queues
    - Binary heaps: basic properties, sift-up, sift-down, insertion, deletion, construction

TEST 2 (Lectures 8-13)
- Comparison-based sorting:
    - Merge sort, including its use for counting inversions
    - Priority queues
    - Binary heaps: basic properties, sift-up, sift-down, insertion, deletion, construction
    - Heap sort
    - Lower bounds on comparison-based sorting
    - Optimally sorting 5 elements
- Address-calculation sorting:
    - Counting sort
    - Bucket sort
    - Radix sort
- External sorting:
    - Polyphase Merge
    - Replacement selection (enhancement to polyphase merge)
- Greedy algorithms:
    - Fractional knapsack
    - Task scheduling to minimize the number of processors required
    - Task scheduling on a uniprocessor to maximize the number of tasks that can be performed
    - Huffman trees and Huffman coding

TEST 3 (Lectures 13-16):
- Greedy algorithms:
    - Huffman trees and Huffman coding
- Divide and conquer
    - Setting up a divide-and-conquer recurrence equation to describe the running time of an algorithm
    - Solving a divide-and-conquer recurrence equation
        - Simplified method
        - Master method
    - Specific divide-and-conquer algorithms
        - Binary search
        - Merge sort
        - Constructing a binary heap
        - Integer multiplication
        - Strassen's method:
            - You do not need to know the detailed equations for Strassen's method
            - You are expected to know that it is possible to multiply two 2-by-2 matrices with 7 scalar multiplications, and understand why this results in a more efficient algorithm for matrix multiplication
- Dynamic Programming
    - The basic approach:
        - Recursion vs. memorized recursion vs. dynamic programming
    - Specific dynamic programming algorithms:
        - Optimal Weighted-interval scheduling


TEST 4 (Lectures 17-20):
- dynamic programming
    - basic approach
        - Recursion vs. memorized recursion vs. dynamic programming
        - expressing the solutions: subproblems, description of function, goal, initial conditions, recurrence equation
        - modifying the program to obtain the optimum strategy in addition to the optimum value
    - specific dynamic programming algorithms
        - optimal weighted-interval scheduling
        - truck-loading problem
        - 0/1 knapsack problem
        - optimal matrix chain multiplication
        - optimal binary trees
- graph basics
    - undirected/directed graphs
    - definitions of basic terms associated with graphs and digraphs
    - formulae for sums of degrees, indegrees, outdegrees
    - paths, cycles, subgraphs, connected components, trees
    - representations of graphs
- topological sorting


TEST 5 (Lectures 21-24):
- weighted graphs
    - shortest paths
        - definition, formulation of problem
        - dijkstra's algorithm
    - minimum spanning trees
        - definition, formulation of problem
        - prim-jarnik algorithm
        - kruskal's algorithm
- selection
    - definition of the median
    - formulation of the selection problem
    - the randomized selection algorithm (QuickSelect)
    - the deterministic selection algorithm (DSelect)
